from astropy.table import Table
import matplotlib.pyplot as plt
from mpl_toolkits import mplot3d
import numpy as np
import time
from sklearn import neighbors

#TODO: Automatic mask generation from VoidFinder if the user doen'st provide an input mask
#from vast.voidfinder.multizmask import generate_mask
from vast.voidfinder._voidfinder_cython_find_next import MaskChecker
from vast.voidfinder.distance import z_to_comoving_dist
from vast.voidfinder import ra_dec_to_xyz
import pickle

#TODO: spellcheck and format documentation
# Test level of detail needed for good uncertainties (repetitions of monte carlo and grid spacing)
# resolve the VoidFinder maximal sphere point-membership issue (see point_query_VF for details)
# add authors to docment (Hernan, Kelly, etc.)
# add verbose option


def calc_volume_boundaries(void_cat_A, void_cat_B):
    """Compute the boundaries of the minimal rectangular volume (parallelpiped)
    that completely contains two void catalogs.
    
    Parameters
    ----------
    void_cat_A : astropy.Table
        Table of void data from first catalog.
    void_cat_B : astropy.Table
        Table of void data from second catalog.
        
    Returns
    -------
    x_min : float
    x_max : float
    y_min : float
    y_max : float
    z_min : float
    z_max : float
    """
    
    x_min = np.minimum(np.min(void_cat_A['x']), np.min(void_cat_B['x']))
    x_max = np.maximum(np.max(void_cat_A['x']), np.max(void_cat_B['x']))
    
    y_min = np.minimum(np.min(void_cat_A['y']), np.min(void_cat_B['y']))
    y_max = np.maximum(np.max(void_cat_A['y']), np.max(void_cat_B['y']))

    z_min = np.minimum(np.min(void_cat_A['z']), np.min(void_cat_B['z']))
    z_max = np.maximum(np.max(void_cat_A['z']), np.max(void_cat_B['z']))

    return x_min, x_max, y_min, y_max, z_min, z_max

def generate_grid_points(x_min, x_max, y_min, y_max, z_min, z_max):
    """Creates a dense rectangular grid of points in 3D for the void volume calculation.
    
    Parameters
    ----------
    x_min : float
    x_max : float
    y_min : float
    y_max : float
    z_min : float
    z_max : float
        The grid boundaries in the x, y, and z dimensions set by calc_volume_boundaries
    
    Returns
    -------
    point_coords : numpy.array with shape (3,N)
        The grid coordinates.
    """
    """
    # The default grid spacing is 1 Megaparsec
    x_range = np.arange(x_min, x_max)
    y_range = np.arange(y_min, y_max)
    z_range = np.arange(z_min, z_max)
    
    """
    #For debuging purposes, we may wish to use a differnet grid spacing
    num_points_in_range = 100
    x_range = np.linspace(x_min, x_max, num_points_in_range) 
    y_range = np.linspace(y_min, y_max, num_points_in_range)
    z_range = np.linspace(z_min, z_max, num_points_in_range)
    

    # Creating a meshgrid from the input ranges 
    X,Y,Z = np.meshgrid(x_range,y_range,z_range)

    x_points = np.ravel(X)
    y_points = np.ravel(Y)
    z_points = np.ravel(Z)
    
    point_coords = np.array([x_points, y_points, z_points])
    
    return point_coords

def mask_point_filter(pts, mask, mask_resolution, rmin, rmax):
    """Determines which grid points generated by generate_grid_points lie in the survey mask
    
    Parameters
    ----------
    pts : numpy.array with shape (3,N)
        The grid points genererated by generate_grid_points
    mask : nmpy.array with shape (N, M)
        The survey mask returned by vast.voidfinder.multizmask.generate_mask
    mask_resolution : int
        The survey mask resolution returend by vast.voidfinder.multizmask.generate_mask
    rmin : float
        The comoving minimum distance within the survey volume
    rmax : float
        The comoving maximum distance within the survey volume
    
    Returns
    -------
    points_in_mask : numpy array
        The list of grid points within the survey mask
    points_boolean: numpy.array
        The indexing array used to select points_in_mask from a full set of grid points
    """
    # Initalize a boolean array to tag points in the mask
    points_boolean = np.ones(pts.shape[1], dtype = bool)
    # Declare MaskChecker object from VAST
    mask_checker = MaskChecker(0,
                            mask,
                            mask_resolution,
                            rmin,
                            rmax)
    
    #Flag points that fall outside the mask
    for i in range(pts.shape[1]):
        # The current point
        curr_pt = pts[:,i]
        # Declare if point is not in mask
        not_in_mask = mask_checker.not_in_mask(curr_pt)
        # Invert not_in_mask to tag points in the mask
        points_boolean[i] = not bool(not_in_mask)
        
    # Select all points in the mask
    points_in_mask = pts[:,points_boolean]
    return points_in_mask, points_boolean


def kd_tree(void_cat):
    """Creates a kdtree from the x-y-z coorinates of a void catalog.
    
    Parameters
    ----------
    void_cat: Astropy Table
        The given void catalogue which includes columns 'x', 'y', and 'z'
    
    Returns
    -------
    sphere_tree: sklearn.neighbors._kd_tree.KDTree
        The kdtree object for the void catalog
    """
    cx = void_cat['x']
    cy = void_cat['y']
    cz = void_cat['z']

    # Format the void centers in an array of shape (N, 3)
    sphere_coords = np.array([cx, cy, cz]).T

    sphere_tree = neighbors.KDTree(sphere_coords)
    
    return sphere_tree

def point_query_VF(point_coords, sphere_tree, void_cat, max_sphere_size):
    """Determines which members of a set of grid points are inside VoidFinder voids
    
    Parameters
    ----------
    point_coords : numpy.array with shape (3,N)
        The grid points within the survey volume
    sphere_tree: sklearn.neighbors._kd_tree.KDTree
        The kdtree object for the void catalog genreated by kd_tree
    void_cat: Astropy Table
        The VoidFinder void catalogue which includes a void radius column 'radius'
    max_sphere_size : float
        A currently unused parameter corresponding to the maximum sphere size in the void catalog
    
    Returns
    -------
    true_inside : numpy.array with shape (3,N)
        Indicates which grid points are inside voids
    dist: numpy.array
        The distance from each grid point to the closest void center
    """
    # Initialize the array that will tag which points are in voids
    true_inside = np.full(point_coords.shape[1], False, dtype=bool)
    
    # k determines the number of nearest neighbors in sphere_tree that are checked for each grid point
    # The default behavior is to check only the single nearest void for void membership
    # It is possible tht more distant voids are very large and enclose a grid point that is not enclsed by
    # its nearest neighbor void, but this sourve of error is currently not accounted for
    # Setting k to a higher value will iprove this error at the cost of runtime
    k = min(sphere_tree.data.shape[0], 1) #change 1 to 5 for testing
    
    #Query the sphere tree
    dist, idx = sphere_tree.query(point_coords.T, k = k)
    
    #Check with points are within void interiors
    interiors = dist < void_cat['radius'][idx]
    # Perform an OR operation on the k interiors columns to tag any point inside any of the k voids as
    # belonging to a void
    for i in range (k):
        true_inside += interiors[:,i]
    """
    # Old (possibly non-funtional) code that uses max_sphere_size to check the complete void catalog for each point's void 
    # membership without having to iterate over each void in the catalog
    # This would be the ideal approach for 100% accuracy, but sphere_tree.query_radius returns a jagged list structure,
    # complicating the otherwise time-efficient numpy array caclulations
    # Revisiting this code may be of interest if we can find a way to speed it up
    ind, dist = sphere_tree.query_radius(point_coords.T, max_sphere_size,return_distance=True)
    true_inside = np.array([np.isin(True, void_cat['radius'][ind_ball]<dist_ball) for (ind_ball,dist_ball) in zip(ind, dist)],dtype=bool)
    """
    return true_inside, dist

def point_query_V2(point_coords, sphere_tree, void_cat):
    """Determines which members of a set of grid points are inside V2 voids
    
    Parameters
    ----------
    point_coords : numpy.array with shape (3,N)
        The grid points within the survey volume
    sphere_tree: sklearn.neighbors._kd_tree.KDTree
        The kdtree object for the void catalog genreated by kd_tree
    void_cat: Astropy Table
        The V2 void catalogue which includes a void radius column 'radius'
    
    Returns
    -------
    true_inside : numpy.array with shape (3,N)
        Indicates which grid points are inside voids
    """
    #(uneeded)Initialize the array that will tag which points are in voids
    #true_inside = np.zeros(point_coords.shape[1])
    #For V2, k=1 is sufficient to ensure 100% accuracy in void membership
    idx = sphere_tree.query(point_coords.T, k = 1, return_distance=False)
    
    true_inside = void_cat[idx]['in_void']

    return true_inside

def prep_V2_cat(V2_galzones, V2_zonevoids, data_table_vl):
    """Formates a V2 catalog for use with the void overlap calclator
    
    Parameters
    ----------
    V2_galzones: Astropy Table
        The V2 galzones catalogue
    V2_zonevoids: Astropy Table
        The V2 zonevoids catalogue
    data_table_vl: Astropy Table
        The glxy catalog used to genreate the V2 void catalog
    Returns
    -------
    V2_galzones : Astropy table
        The V2_galzones object formatted for use with teh volume overlap caculator
    """
    
    #TODO: remove hardcoding of these values and allow user to set them
    omega_M = np.float32(0.3)
    h = np.float32(1.0)
    
    #index the galaxies in the galaxy catalog
    if ~np.isin("index",data_table_vl.colnames):
        data_table_vl['index'] = np.arange(len(data_table_vl))
    
    #sort the catalogs
    data_table_vl.sort('index')
    V2_galzones.sort('gal')
    
    # Ensure that each galaxy int the catalog has a zone inthe galzones file
    assert len(data_table_vl) == len(V2_galzones)

    # modify the galaxy table column names
    # WARNING: don't input a catalog with x-y-z coordinates and no 'redshift' column 
    # TODO: make this warning more clear to user
    if ~np.isin("redshift",data_table_vl.colnames):
        data_table_vl['z'].name = "redshift"
    
    #calculate galaxy comoving distances
    Rgal = z_to_comoving_dist(data_table_vl['redshift'].astype(np.float32),omega_M,h)
    data_table_vl['Rgal'] = Rgal

    # Select onpy galaxies with positive redshift 
    z_boolean = data_table_vl['redshift']>0 
    data_table_vl = data_table_vl[z_boolean]
    
    #calculate the xyz coordinates
    galaxies_xyz = ra_dec_to_xyz(data_table_vl)
    V2_galzones['x'] = galaxies_xyz[:,0]
    V2_galzones['y'] = galaxies_xyz[:,1]
    V2_galzones['z'] = galaxies_xyz[:,2]
    
    # Mark zones that belong to voids
    V2_galzones['in_void'] = V2_zonevoids[V2_galzones['zone']]['void1'] > -1
    
    return V2_galzones

class OverlapCalculator():
    
    def __init__ (self, data_table_V1, data_table_V2, title1, title2, mask_file, rmin, rmax, galaxy_table = None, zone_table_V1 = None, zone_table_V2 = None, use_mask = True, V1_algorithm="VF", V2_algorithm="VF"):
        self.max_sphere_size = 0
        
        if V1_algorithm=="V2":
            data_table_V1 = prep_V2_cat(data_table_V1, zone_table_V1, galaxy_table)
        else:
            self.max_sphere_size = np.max(data_table_V1["radius"])
            
        if V2_algorithm=="V2":
            data_table_V2 = prep_V2_cat(data_table_V2, zone_table_V2, galaxy_table)
        else:
            self.max_sphere_size = np.maximum(np.max(data_table_V2["radius"]), self.max_sphere_size)
               
        self.data_table_V1 = data_table_V1
        self.data_table_V2 = data_table_V2
        self.title1 = title1
        self.title2 = title2
        
        self.use_mask = use_mask
        
        
        
        self.V1_algorithm = V1_algorithm
        self.V2_algorithm = V2_algorithm
        

        if use_mask:
            temp_infile = open(mask_file, 'rb')
            self.mask, self.mask_resolution, _ = pickle.load(temp_infile)
            temp_infile.close()

            self.rmin = rmin
            self.rmax = rmax
        
    def find_overlap(self):
        
        #This line creates the boundaries (like the whole min and max)
        xmin, xmax, ymin, ymax, zmin, zmax = calc_volume_boundaries(self.data_table_V1, self.data_table_V2)

        #This line makes creates the points in between 
        pts = generate_grid_points(xmin, xmax, ymin, ymax, zmin, zmax)
        
        if self.use_mask: #case of survey mask
            #points_boolean isn't further used, not sure why the mask_point_filter function returns it
            #can modify the function to not return it
            points_in_mask, points_boolean = mask_point_filter(pts, 
                                                               self.mask, 
                                                               self.mask_resolution, 
                                                               self.rmin, 
                                                               self.rmax)
            self.pim = points_in_mask
        else: #case of cubic volume
            points_in_mask = pts

        (var, self.n_points) = points_in_mask.shape
        
        U = 1

        self.count_in_V1 = np.zeros(U)
        self.count_out_V1 = np.zeros(U)

        self.count_in_V2 = np.zeros(U)
        self.count_out_V2 = np.zeros(U)

        self.inside_both = np.zeros(U)
        self.inside_neither = np.zeros(U)
        self.inside_V1 = np.zeros(U)
        self.inside_V2 = np.zeros(U)

        points_in_mask_copy = points_in_mask.copy()

        kdTree_V1 = kd_tree(self.data_table_V1)
        kdTree_V2 = kd_tree(self.data_table_V2)

        
        for i in range(U):

            delta = np.random.rand(3)

            points_in_mask_copy[0] = points_in_mask[0] + delta[0]
            points_in_mask_copy[1] = points_in_mask[1] + delta[1]
            points_in_mask_copy[2] = points_in_mask[2] + delta[2]

            # print(points_in_mask_copy[:,:10])
            
            if self.V1_algorithm == "VF":
                #remove dist from the function return once you're done testing
                true_inside_V1, dist = point_query_VF(points_in_mask_copy, kdTree_V1, self.data_table_V1, self.max_sphere_size)
                
            elif self.V1_algorithm == "V2":
                true_inside_V1 = point_query_V2(points_in_mask_copy, kdTree_V1, self.data_table_V1).data.T[0]
               
            self.count_in_V1[i] = np.sum(true_inside_V1)

            # The "~" inverts the array. So we have true_inside inverted to add up the falses instead of the trues
            self.count_out_V1[i] = np.sum(~true_inside_V1)

            # print(time.time() - start_time)

            if self.V2_algorithm == "VF":
                true_inside_V2, dist = point_query_VF(points_in_mask_copy, kdTree_V2, self.data_table_V2, self.max_sphere_size)
                self.dist=dist
            elif self.V2_algorithm == "V2":
                true_inside_V2 = point_query_V2(points_in_mask_copy, kdTree_V2, self.data_table_V2).data.T[0]
                
            self.count_in_V2[i] = np.sum(true_inside_V2)
            # The "~" inverts the array. So we have true_inside inverted to add up the falses instead of the trues
            self.count_out_V2[i] = np.sum(~true_inside_V2)
            #total_DEL = count_in_DEL + count_out_DEL

            # This is the number of points that are inside both A and B
            self.inside_V1_and_V2 = np.logical_and(true_inside_V1, true_inside_V2)
            self.inside_both[i] = np.sum(self.inside_V1_and_V2)

            # This is the number of points that are in neither A and B
            self.not_inside_V1_and_V2 = np.logical_and(~true_inside_V1, ~true_inside_V2)
            self.inside_neither[i] = np.sum(self.not_inside_V1_and_V2)
            # This is the number of points that are in A but not B
            self.inside_v1 = np.logical_and(true_inside_V1, ~true_inside_V2)
            self.inside_V1[i] = np.sum(self.inside_v1)

            # This is the number of points that are not in A but are in B
            self.inside_v2 = np.logical_and(~true_inside_V1, true_inside_V2)
            self.inside_V2[i] = np.sum(self.inside_v2)

        self.inside_V1_and_V2 = np.logical_and(true_inside_V1, true_inside_V2)
        self.not_inside_V1_and_V2 = np.logical_and(~true_inside_V1, ~true_inside_V2)
        self.inside_V1 = np.logical_and(true_inside_V1, ~true_inside_V2)
        self.inside_V2 = np.logical_and(~true_inside_V1, true_inside_V2)

        self.r_V1 = self.count_in_V1 / self.n_points
        self.r_V2 = self.count_in_V2 / self.n_points
        self.r_V1_V2 = np.sum(self.inside_V1_and_V2) / self.n_points
        self.r_not_V1_V2 = np.sum(self.not_inside_V1_and_V2) / self.n_points
        self.r_V1_not_V2 = np.sum(self.inside_V1) / self.n_points
        self.r_V2_not_V1 = np.sum(self.inside_V2) / self.n_points
        
        #problem is that the point only marks itself as in/out of void with respect to its nearest neighbor void, when another void might be farther away but be physically bigger and contain it
    
    def plot(self):
        fig = plt.figure()
        plt.pie(
            [self.r_V1_V2, self.r_not_V1_V2, self.r_V2_not_V1, self.r_V1_not_V2],
            labels=[
                f"Common to {self.title1}/{self.title2} Voids",
                "Exterior to All Voids",
                f"Unique to {self.title2} Voids",
                f"Unique to {self.title1} Voids"
            ]
        )

        plt.title(f"Volume Overlap of {self.title1} and {self.title2} Voids")
        
        return fig
    
    def report(self):
        print("Number of points used:", self.n_points)
        print(f"Common to {self.title1}/{self.title2} Voids:", self.r_V1_V2)
        print("Exterior to All Voids:", self.r_not_V1_V2)
        print(f"Unique to {self.title2} Voids:", self.r_V2_not_V1)
        print(f"Unique to {self.title1} Voids:", self.r_V1_not_V2)